# 동시성 제어 테스트 보고서

### 배경
여러 사용자가 동시에 포인트 충전 및 사용 요청을 보낼 경우, 데이터의 일관성을 보장하지 못할 가능성이 존재.

### 주요 요구사항
- **동시성 제어**: 여러 요청이 동시에 들어와도 데이터의 일관성을 유지.
- **병목 현상 확인 및 완화**: 동시 요청이 많아질수록 시스템의 성능 저하를 방지.

---

## 1. **고민한 점**

1. **동시성 제어란 무엇인가?**
    - 여러 스레드가 동일한 자원에 접근할 때 발생할 수 있는 충돌을 방지하는 기술.
    - 데이터의 정확성을 유지하면서도 성능 저하를 최소화하는 방법이 필요.

2. **초보자의 관점에서 떠오른 의문**
    - 동시 요청에서 어떤 문제가 발생하는가?
    - 이를 해결하기 위한 방법에는 무엇이 있는가?
    - 각 방법의 장단점은 무엇인가?

---

## 2. **적용한 동시성 제어 방법**

### 2.1 **`synchronized` 키워드**
#### 설명
- 자바에서 가장 기본적인 동시성 제어 방법.
- 메소드 또는 블록에 `synchronized`를 선언하여 단일 스레드만 접근 가능하도록 제한.

#### 테스트 방법
- 한 사용자가 100번의 동시 요청을 보냈을 때 데이터가 정확히 유지되는지 확인.

#### 결과
- 데이터 일관성 유지 확인.
- **문제점**: 
  - 병목 현상이 발생하여 처리 속도가 느림.
  - 모든 요청이 순차적으로 처리되므로 성능 저하.

---

### 2.2 **`ReentrantLock`**
#### 설명
- 명시적으로 Lock을 생성하여 스레드 간 자원 접근을 제어.
- 필요할 때만 Lock을 걸고, `unlock()`을 호출하여 성능 개선 가능.

#### 테스트 방법
- `ReentrantLock`을 활용하여 포인트 충전 및 사용 요청을 처리.

#### 결과
- 데이터 일관성 유지 확인.
- **문제점**: 
  - 코드가 길어지고 복잡도가 증가.
  - 명시적인 `lock()` 및 `unlock()` 호출이 필요.

---

### 2.3 **`ConcurrentHashMap`과 사용자별 Lock**
#### 설명
- `ConcurrentHashMap`을 사용하여 사용자별로 Lock을 관리.
- 요청이 특정 사용자에만 영향을 미치므로 성능 개선 가능.

#### 테스트 방법
- 각 사용자 ID에 대한 Lock을 `ConcurrentHashMap`으로 관리.

#### 결과
- 데이터 일관성 유지 확인.
- **문제점**: 
  - 많은 사용자에 대해 Lock 객체를 생성하면 메모리 사용량이 증가.

---

### 2.4 **공정 모드 (`ReentrantLock` with Fair Mode)**
#### 설명
- `ReentrantLock`에 공정 모드를 활성화하여 스레드 처리 순서를 보장.

#### 테스트 방법
- 공정 모드를 활성화하여 동시 요청에서 처리 순서가 공평하게 유지되는지 확인.

#### 결과
- 데이터 일관성 유지 확인.
- 병목 현상이 완화됨.
- **문제점**:
  - 공정 모드로 인해 일부 스레드의 처리 시간이 길어질 수 있음.

---

## 3. **결론 및 배운 점**

### 구현 과정에서 배운 것
1. **동시성 제어의 중요성**
    - 데이터를 정확히 관리하기 위해 동시 요청 처리에 대한 깊은 이해가 필요.

2. **다양한 접근 방법**
    - `synchronized`는 간단하지만 성능이 떨어짐.
    - `ReentrantLock`과 `ConcurrentHashMap`은 성능 개선 가능.
    - 공정 모드는 병목 현상을 완화하지만 모든 경우에 적합하지 않을 수 있음.

---
